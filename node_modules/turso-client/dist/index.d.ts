// Generated by dts-bundle-generator v9.5.1

export interface DatabaseResponse {
	Name: string;
	DbId: string;
	Hostname: string;
	block_reads: boolean;
	block_writes: boolean;
	allow_attach: boolean;
	regions: string[];
	primaryRegion: string;
	type: string;
	version: string;
	group: string;
	is_schema: boolean;
	schema: string;
	sleeping: boolean;
}
export interface CreateDatabaseBody {
	name: string;
	group: string;
	seed?: {
		type?: "database" | "dump";
		name?: string;
		url?: string;
		timestamp?: string;
	};
	size_limit?: string;
	is_schema?: boolean;
	schema?: string;
}
export interface CreateDatabaseResponse {
	DbId: string;
	Hostname: string;
	Name: string;
}
export interface createTokenQuery {
	expiration?: string;
	authorization?: "full-access" | "read-only";
}
export interface createTokenBody {
	permissions: {
		read_attach: {
			databases: string[];
		};
	};
}
export interface retriveConfigurationResponse {
	size_limit: string;
	allow_attach: boolean;
	block_reads: boolean;
	block_writes: boolean;
}
export interface LocationsResponse {
	locations: {
		[key: string]: string;
	};
}
export interface ClosestRegionResponse {
	server: string;
	client: string;
}
export interface listMembersReponse {
	username: string;
	role: string;
	email: string;
}
export interface createMemberBody {
	username: string;
	role: "admin" | "member";
}
export interface createMemberResponse {
	member: string;
	role: string;
}
export interface ListResponse {
	name: string;
	slug: string;
	type: string;
	plan_id?: string;
	overages: boolean;
	blocked_reads: boolean;
	blocked_writes: boolean;
	plan_timeline?: string;
	memory?: number;
	payment_failing_since?: PaymentFailingSince;
}
export interface PaymentFailingSince {
	Time: string;
	Valid: boolean;
}
export interface createTokenResponse {
	name: string;
	id: string;
	token: string;
}
export interface validateTokenResponse {
	exp: number;
}
export interface listTokensResponse {
	name: string;
	id: string;
}
export interface revokeTokenResponse {
	token: string;
}
export type ApiClientOptions = {
	apiKey: string;
};
export declare class TursoClient {
	private readonly baseUrl;
	private readonly apiKey;
	private readonly regionUrl;
	constructor(opts: ApiClientOptions);
	private request;
	readonly apiTokens: {
		create: (tokenName: string) => Promise<createTokenResponse>;
		validate: () => Promise<validateTokenResponse>;
		list: () => Promise<{
			tokens: listTokensResponse[];
		}>;
		revoke: (tokenName: string) => Promise<revokeTokenResponse>;
	};
	readonly databases: {
		/**
		 * List databases for an organization
		 * @param organizationName The name of the organization
		 * @param group The group name
		 * @param schema Filter by schema database name
		 * @returns DatabaseResponse
		 */
		list: (organizationName: string, group?: string, schema?: string) => Promise<DatabaseResponse>;
		/**
		 * Create a new database
		 * @param organizationName
		 * @param CreateDatabaseBody
		 * @returns CreateDatabaseResponse
		 */
		create: (organizationName: string, body: CreateDatabaseBody) => Promise<{
			database: CreateDatabaseResponse;
		}>;
		/**
		 * Retrieve the details of a specific database within an organization.
		 *
		 * @param organizationName - The name of the organization.
		 * @param databaseName - The name of the database to retrieve.
		 * @returns Promise<{ database: DatabaseResponse }> - A promise that resolves to the database details.
		 */
		retrieve: (organizationName: string, databaseName: string) => Promise<{
			database: DatabaseResponse;
		}>;
		/**
		 * Retrieve the configuration details of a specific database within an organization.
		 *
		 * @param organizationName - The name of the organization.
		 * @param databaseName - The name of the database to retrieve the configuration for.
		 * @returns Promise<{ configuration: retriveConfigurationResponse }> - A promise that resolves to the database configuration details.
		 */
		retrieveConfiguration: (organizationName: string, databaseName: string) => Promise<{
			configuration: retriveConfigurationResponse;
		}>;
		/**
		 * Delete a specific database within an organization.
		 *
		 * @param organizationName - The name of the organization.
		 * @param databaseName - The name of the database to delete.
		 * @returns Promise<{ database: string }> - A promise that resolves to the result of the deletion.
		 */
		delete: (organizationName: string, databaseName: string) => Promise<{
			database: string;
		}>;
		/**
		 * Create a new token for a specific database within an organization.
		 *
		 * @param organizationName - The name of the organization.
		 * @param databaseName - The name of the database to create a token for.
		 * @param queryParams - Optional query parameters for the request.
		 * @param body - Optional body parameters for the request.
		 * @returns Promise<{ jwt: string }> - A promise that resolves to the new token.
		 */
		createToken: (organizationName: string, databaseName: string, queryParams?: createTokenQuery, body?: createTokenBody) => Promise<{
			jwt: string;
		}>;
		/**
		 * Rotate the token for a specific database within an organization.
		 *
		 * @param organizationName - The name of the organization.
		 * @param databaseName - The name of the database to rotate the token for.
		 * @returns Promise<void> - A promise that resolves when the token has been rotated.
		 */
		invalidateToken: (organizationName: string, databaseName: string) => Promise<void>;
		/**
		 * List instances for a specific database within an organization.
		 *
		 * @param organizationName - The name of the organization.
		 * @param databaseName - The name of the database to list instances for.
		 * @returns Promise<{ instances: string[] }> - A promise that resolves to the list of instances.
		 */
		listInstances: (organizationName: string, databaseName: string) => Promise<{
			instances: string[];
		}>;
	};
	readonly locations: {
		list: () => Promise<LocationsResponse>;
		closest: () => Promise<ClosestRegionResponse>;
	};
	readonly organizations: {
		list: () => Promise<ListResponse[]>;
	};
	readonly members: {
		list: (organizationName: string) => Promise<{
			members: listMembersReponse[];
		}>;
		add: (organizationName: string, body: createMemberBody) => Promise<createMemberResponse>;
		remove: (organizationName: string, username: string) => Promise<{
			member: string;
		}>;
	};
}

export {};
